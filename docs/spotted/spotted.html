<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>spotted.spotted API documentation</title>
<meta name="description" content="Spotted" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spotted.spotted</code></h1>
</header>
<section id="section-intro">
<p>Spotted</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Spotted
&#34;&#34;&#34;

import math
import json
import time
import threading
import socket
import asyncio
import itertools
import queue
from http.server import HTTPServer
from datetime import datetime

import netifaces
import websockets
import numpy as np
import cv2 as cv

from artnet.dmx import Dmx
from artnet.poll import Poll
from artnet.poll_reply import PollReply
from artnet.deserialize import identify_header
from artnet.opcode import Opcode
from spotted.camera import Camera
from spotted.personality import load_personalities
from spotted.point_of_interest import PointOfInterest
from spotted.fixture import Fixture
from spotted.universe import Universe
from spotted.universes import Universes
from spotted.coordinate import Coordinate
from spotted.room import Room
from spotted.calibration import Calibration
from spotted.websocket import Websocket
from spotted.static_server import StaticServer
from spotted.helpers import handler_class_with_args
from spotted.error import ErrorCode, exit_with_error
from config.system import SystemConfig

# pylint: disable=too-many-instance-attributes
class Spotted:
  &#34;&#34;&#34;
  Spotted
  &#34;&#34;&#34;

  def __init__(self, skip_cameras=False):
    &#34;&#34;&#34;
    Create spotted instance
    Sets up state, calibration, personalities, cameras, room, fixtures and universes
    &#34;&#34;&#34;

    self.skip_cameras = skip_cameras

    self.cameras = []
    self.room = None
    self.universes = Universes()
    self.pois = []
    self.max_subjects = None
    self.calibration = None

    self.init_config()

    self.threads = {}
    self.setup_interface()

  def init_config(self):
    &#34;&#34;&#34;
    Initialises all backend services in a repeatable fashion, allowing Spotted
    to be partially restarted when config changes
    &#34;&#34;&#34;

    try:
      self.config = json.load(open(&#39;config/config.json&#39;))
      load_personalities(&#39;config/personalities.json&#39;)
    except FileNotFoundError as error:
      exit_with_error(ErrorCode.MissingConfig, error)

    self.current_state = dict()
    self.stop_flags = {
      &#39;artnet&#39;: False,
      &#39;camera&#39;: False,
      &#39;fixture&#39;: False
    }

    self.setup_calibration()
    self.cameras = []
    if not self.skip_cameras:
      self.setup_cameras()
    self.setup_room()
    self.universes = Universes()
    self.pois = []
    self.setup_fixtures()
    self.setup_max_subjects()

  def setup_interface(self):
    &#34;&#34;&#34;
    Validates configured interfaces against available system interfaces and
    returns the first IPv4 address of the given interface
    &#34;&#34;&#34;

    host_interfaces = netifaces.interfaces()

    if &#39;network_interface&#39; in self.config:
      if self.config[&#39;network_interface&#39;] in host_interfaces:
        addresses = netifaces.ifaddresses(self.config[&#39;network_interface&#39;])
        if netifaces.AF_INET in addresses:
          address = addresses[netifaces.AF_INET][0]
          self.ip_address = address[&#39;addr&#39;]
          self.broadcast_address = address[&#39;broadcast&#39;]
        else:
          exit_with_error(ErrorCode.InterfaceAddress, self.config[&#39;network_interface&#39;])
      else:
        details = (self.config[&#39;network_interface&#39;], host_interfaces)
        exit_with_error(ErrorCode.MissingInterface, details)
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;network_interface&#39;)

  def setup_calibration(self):
    &#34;&#34;&#34;
    Creates the calibration object from config
    &#34;&#34;&#34;

    if &#39;calibration&#39; in self.config:
      self.calibration = Calibration(self.config[&#39;calibration&#39;])
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;calibration&#39;)

  def setup_cameras(self):
    &#34;&#34;&#34;
    Defines the cameras from config
    &#34;&#34;&#34;

    if &#39;cameras&#39; in self.config:
      if len(self.config[&#39;cameras&#39;]) &lt; 1:
        exit_with_error(ErrorCode.EmptyKey, &#39;cameras&#39;)

      for camera_id, camera in self.config[&#39;cameras&#39;].items():
        cam = Camera(camera, camera_id, self.calibration, self.stop_flags)
        self.cameras.append(cam)
        self.config[&#39;cameras&#39;][camera_id][&#39;initial_point&#39;] = cam.initial_point.as_dict()
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;cameras&#39;)

    for camera in self.cameras:
      if not camera.capture.isOpened():
        exit_with_error(ErrorCode.CameraConnect, camera.cam_id)

  def setup_room(self):
    &#34;&#34;&#34;
    Defines the room from config
    &#34;&#34;&#34;

    if &#39;room&#39; in self.config:
      room_json = self.config[&#39;room&#39;]
      self.room = Room(room_json[&#39;x&#39;], room_json[&#39;y&#39;], room_json[&#39;z&#39;])
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;room&#39;)

  def setup_max_subjects(self):
    &#34;&#34;&#34;
    Defines the maximum tracked subjects from config
    &#34;&#34;&#34;

    if &#39;max_subjects&#39; in self.config:
      self.max_subjects = self.config[&#39;max_subjects&#39;]
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;max_subjects&#39;)

  def setup_fixtures(self):
    &#34;&#34;&#34;
    Creates the fixture structure from config
    &#34;&#34;&#34;

    if &#39;fixtures&#39; in self.config:
      if len(self.config[&#39;fixtures&#39;]) &lt; 1:
        exit_with_error(ErrorCode.EmptyKey, &#39;fixtures&#39;)

      for fixture_id, fixture_config in self.config[&#39;fixtures&#39;].items():
        fixture = Fixture(fixture_config, fixture_id, self.stop_flags)
        addr = fixture.address
        universe = self.universes.get_universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
        if universe is None:
          universe = Universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
          self.universes.add_universe(universe)
        universe.add_fixture(fixture)
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;fixtures&#39;)

  # pylint: disable=invalid-name, too-many-locals
  def calculate_intersection(self, poi1, poi2, close_enough, points):
    &#34;&#34;&#34;
    Determines if poi1 is close enough to poi2 to be a possibility for an intersection
    &#34;&#34;&#34;

    u = poi1.direction_vector
    v = poi2.direction_vector

    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)

    w = np.subtract(poi1.position.as_vector(), poi2.position.as_vector())
    d = np.dot(u, w)
    e = np.dot(v, w)

    acb = (a * c) - (b * b)

    s = np.dot(((b * e) - (c * d)) / acb, u)
    t = np.dot(((a * e) - (b * d)) / acb, v)

    z = abs(np.subtract(t, s))

    distance = np.add(w, z)

    euclid_distance = math.sqrt(distance[0]**2 + distance[1]**2 + distance[2]**2)

    # print(&#39;distance:&#39;, euclid_distance)

    if euclid_distance &gt; 1:
      close_enough = False
    else:
      ps = np.add(poi1.position.as_vector(), s)
      qt = np.add(poi2.position.as_vector(), t)
      abs_point = np.add(qt, ps) / 2
      if not(
          (0 &lt;= abs_point[0] &lt;= self.room.width) and
          (0 &lt;= abs_point[1] &lt;= self.room.height) and
          (0 &lt;= abs_point[2] &lt;= self.room.depth)
      ):
        close_enough = False
      else:
        points.append(abs_point)

    return (close_enough, points)

  def update_pois(self):
    &#34;&#34;&#34;
    Update 3D points of interest from all camera pois
    &#34;&#34;&#34;
    current_pois = self.combine_points()

    updated_pois = []

    # print(&#39;There are&#39;, len(current_pois), &#39;pois coming in&#39;)

    for incoming_poi in current_pois:
      new_position = incoming_poi.position
      made_update = False
      if len(self.pois) &gt; 0:
        poi = sorted(self.pois, key=lambda p, np=new_position: p.diff_from_position(np))[0]
        diff_from_pos = poi.diff_from_position(new_position)
        if diff_from_pos &lt; 1:
          # print(&#39;Updated position&#39;)
          poi.update_position(new_position)
          poi.increment_count()
          updated_pois.append(poi)
          made_update = True
          break

        if not made_update:
          poi = PointOfInterest(new_position, decrement_step=5)
          updated_pois.append(poi)
          self.pois.append(poi)
      else:
        poi = PointOfInterest(new_position, decrement_step=5)
        updated_pois.append(poi)
        self.pois.append(poi)


    missing_pois = set(self.pois) - set(updated_pois)
    for poi in missing_pois:
      poi.decrement_count()

    self.pois = [p for p in self.pois if p.count != 1]
    self.pois = sorted(self.pois, key=lambda p: p.weight, reverse=True)

  def combine_points(self):
    &#34;&#34;&#34;
    Intersects all points from all cameras to find possible 3d world points of
    interest
    &#34;&#34;&#34;

    fixture_positions = []
    for universe in self.universes.universes:
      for fixture in universe.fixtures:
        if fixture.last_position is not None:
          fixture_positions.append(fixture.last_position)

    threshold = 25

    pois = []
    for camera in self.cameras:
      fixture_camera_coordinates = []
      # inverse_rotation = np.linalg.inv(camera.rotation_matrix)
      # for fixt_pos in fixture_positions:
      #   displaced = (fixt_pos - camera.position).as_vector()

      #   # print(&#39;displaced:&#39;, displaced)

      #   # print(&#39;inverse_rotation:&#39;, inverse_rotation)

      #   identity = inverse_rotation[0].dot(displaced)
      #   identity = inverse_rotation[1].dot(identity)
      #   identity = inverse_rotation[2].dot(identity)

      #   # identity = identity

      #   print(&#39;identity:&#39;, identity)

      #   angular_displacement_horizontal = math.degrees(math.atan2(identity[2], identity[0]))
      #   angular_displacement_vertical = -math.degrees(math.atan2(identity[1], identity[0]))

      #   print(&#39;angular_displacement_horizontal:&#39;, angular_displacement_horizontal)
      #   print(&#39;angular_displacement_vertical:&#39;, angular_displacement_vertical)

      #   displacement_horizontal = round(
      #     scale(
      #       angular_displacement_horizontal,
      #       0, camera.angular_horiz_midpoint,
      #       0, camera.horiz_midpoint
      #     ) + camera.horiz_midpoint
      #   )
      #   displacement_vertical = round(
      #     scale(
      #       angular_displacement_vertical,
      #       0, camera.angular_vert_midpoint,
      #       0, camera.vert_midpoint
      #     ) + camera.vert_midpoint
      #   )

      #   print(&#39;predicted camera coordinates are&#39;, displacement_horizontal, displacement_vertical)

      #   fixture_camera_coordinates.append((displacement_horizontal, displacement_vertical))

      #   camera.current_background = np.zeros(camera.resolution_yx, dtype=np.uint8)

      #   camera_fixture_position = (displacement_vertical, displacement_horizontal)
      #   cv.circle(camera.current_background, camera_fixture_position, 15, 255, 2)

      possible_camera_pois = camera.points_of_interest
      camera_pois = []
      for poi in possible_camera_pois:
        collision = False
        for fixt_pos in fixture_camera_coordinates:
          lx, ly = poi.location
          fx, fy = fixt_pos

          if abs(lx - fx) &lt; threshold and abs(ly - fy) &lt; threshold:
            print(&#39;poi got too close&#39;)
            # collision = True

        if not collision:
          camera_pois.append(poi)





      pois.append(camera_pois)

    if len(pois) == 0:
      return []

    pois = list(itertools.product(*pois))

    # print(&#39;There are&#39;, len(pois), &#39;possible pois&#39;)

    points_of_interest = []

    for poi in pois:
      close_enough = True

      points = []

      for poi1, poi2 in itertools.combinations(poi, len(poi)):
        close, points = self.calculate_intersection(poi1, poi2, close_enough, points)
        if not close:
          close_enough = False

      if close_enough:
        poi = PointOfInterest(Coordinate(*np.mean(list(zip(*points)), axis=1)))
        points_of_interest.append(poi)

    return points_of_interest

  def start_artnet(self, transmit):
    &#34;&#34;&#34;
    Art-Net data stream generator

    Arguments:
      transmit {Queue} -- Queue to place transmittable packets onto
    &#34;&#34;&#34;

    last_poll_transmission = datetime.now()

    delay = 1
    if SystemConfig.transmit_rate == &#39;continuous&#39;:
      delay = 1/50
    elif SystemConfig.transmit_rate == &#39;reduced&#39;:
      delay = 1/15

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      # Send ArtPoll every 3 seconds
      if (datetime.now() - last_poll_transmission).total_seconds() &gt; 3:
        last_poll_transmission = datetime.now()
        packet = Poll()
        transmit.put(packet)

      for universe in self.universes.universes:
        packet = Dmx(0, universe)
        transmit.put(packet)
      time.sleep(delay)

  def start_artnet_reply(self, transmit):
    &#34;&#34;&#34;
    Listens for ArtPoll packets, and replies as necessary

    Arguments:
      transmit {Queue} -- Queue to place transmittable packets onto
    &#34;&#34;&#34;
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.setblocking(False)
    sock.bind((self.broadcast_address, 6454))

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      try:
        incoming = sock.recv(1024)

        if len(incoming) &gt; 0:
          valid, opcode, packet = identify_header(incoming)
          if valid:
            if opcode is Opcode.OpPoll:
              packet = PollReply(0, 0, self.ip_address, [0x50, 0x1A, 0xC5, 0xE7, 0xD6, 0x8F])
              transmit.put(packet)
      except BlockingIOError:
        time.sleep(1/50)

  def artnet_transmitter(self, transmit):
    &#34;&#34;&#34;
    Transmits Art-Net packets from the supplied queue constantly

    Arguments:
      transmit {Queue} -- Queue to transmit from
    &#34;&#34;&#34;

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.bind((self.ip_address, 6454))
    print(&#39;Starting artnet&#39;)

    delay = 1
    if SystemConfig.transmit_rate == &#39;continuous&#39;:
      delay = 1/50
    elif SystemConfig.transmit_rate == &#39;reduced&#39;:
      delay = 1/15

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      try:
        if self.stop_flags[&#39;artnet&#39;]:
          break
        packet = transmit.get_nowait()
        sock.sendto(packet.serialize(), (self.broadcast_address, 6454))
      except queue.Empty:
        time.sleep(delay)

  def start_ui(self, server_class=HTTPServer, handler_class=StaticServer, port=8080):
    &#34;&#34;&#34;
    UI thread
    &#34;&#34;&#34;

    print(&#39;Starting UI on port&#39;, port)
    server_address = (&#39;&#39;, port)
    handler = handler_class_with_args(handler_class, self)
    httpd = server_class(server_address, handler)
    httpd.serve_forever()

  def start_websocket(self, port=8081):
    &#34;&#34;&#34;
    Websocket thread
    &#34;&#34;&#34;

    print(&#39;Starting websocket server on port&#39;, port)
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    websocket = Websocket(self)
    start_server = websockets.serve(websocket.push_state, &#39;0.0.0.0&#39;, port)
    loop.create_task(websocket.broadcast_state(1/30))
    loop.run_until_complete(start_server)
    loop.run_forever()

  def start_support_threads(self, daemon):
    &#34;&#34;&#34;
    Start all backend service threads in one go

    Arguments:
      daemon {bool} -- Start threads in daemon mode or not
    &#34;&#34;&#34;

    self.threads[&#39;cameras&#39;] = []
    for camera in self.cameras:
      thread = threading.Thread(target=camera.begin_capture, daemon=daemon)
      self.threads[&#39;cameras&#39;] = self.threads[&#39;cameras&#39;] + [thread]
      thread.start()

    transmit = queue.Queue()

    self.threads[&#39;artnet&#39;] = [
      threading.Thread(target=self.start_artnet, args=(transmit,), daemon=daemon),
      threading.Thread(target=self.start_artnet_reply, args=(transmit,), daemon=daemon),
      threading.Thread(target=self.artnet_transmitter, args=(transmit,), daemon=daemon)
    ]

    for thread in self.threads[&#39;artnet&#39;]:
      thread.start()

    self.threads[&#39;fixtures&#39;] = []
    for universe in self.universes.universes:
      for fixture in universe.fixtures:
        thread = threading.Thread(target=fixture.follow, daemon=daemon)
        self.threads[&#39;fixtures&#39;] = self.threads[&#39;fixtures&#39;] + [thread]
        thread.start()

  def start_spotted(self):
    &#34;&#34;&#34;
    Starts up all essential threads and drops to processing points from cameras
    &#34;&#34;&#34;

    daemon = False

    self.threads[&#39;ui&#39;] = [
      threading.Thread(target=self.start_ui, daemon=daemon),
      threading.Thread(target=self.start_websocket, daemon=daemon)
    ]
    for thread in self.threads[&#39;ui&#39;]:
      thread.start()

    self.start_support_threads(daemon)

    while True:
      # Uncomment this block for static values
      # point = Coordinate(2.0, 0.0, 4.0)
      # for fixture in self.universes.universes[0].fixtures:
      #   fixture.point_at(self.cameras[1].initial_point)
      #   fixture.open()
      #   # self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[index])
      # time.sleep(1/30)
      # continue

      self.update_pois()

      live_pois = self.pois

      self.current_state[&#39;cameras&#39;] = {}
      for camera in self.cameras:
        poi_positions = [poi.position.as_vector().tolist() for poi in camera.points_of_interest]
        self.current_state[&#39;cameras&#39;][camera.cam_id] = poi_positions

      self.current_state[&#39;subjects&#39;] = {}
      for poi in live_pois:
        self.current_state[&#39;subjects&#39;][id(poi)] = poi.position.as_dict()

      self.current_state[&#39;maps&#39;] = dict()

      current_poi_index = -1
      for universe in self.universes.universes:
        for fixture in universe.fixtures:
          if len(live_pois) &gt; 0:
            current_poi_index = (current_poi_index + 1) % self.max_subjects
            if current_poi_index &gt;= len(live_pois): # We&#39;ve got less than max subjects
              current_poi_index = 0
            fixture.point_at(live_pois[current_poi_index].position)
            fixture.open()

            self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[current_poi_index])

          else:
            fixture.close()

      if len(self.cameras) &gt;= 2:
        out_frame = None
        if self.cameras[0].current_frame is not None:
          out_frame = self.cameras[0].current_frame
        if self.cameras[1].current_frame is not None:
          if out_frame is not None:
            out_frame = np.vstack((out_frame, self.cameras[1].current_frame))
          else:
            out_frame = self.cameras[1].current_frame
        if out_frame is not None:
          cv.imshow(&#39;VIDEO&#39;, out_frame)
          cv.waitKey(1)
      time.sleep(1/30)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spotted.spotted.Spotted"><code class="flex name class">
<span>class <span class="ident">Spotted</span></span>
<span>(</span><span>skip_cameras=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Spotted</p>
<p>Create spotted instance
Sets up state, calibration, personalities, cameras, room, fixtures and universes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spotted:
  &#34;&#34;&#34;
  Spotted
  &#34;&#34;&#34;

  def __init__(self, skip_cameras=False):
    &#34;&#34;&#34;
    Create spotted instance
    Sets up state, calibration, personalities, cameras, room, fixtures and universes
    &#34;&#34;&#34;

    self.skip_cameras = skip_cameras

    self.cameras = []
    self.room = None
    self.universes = Universes()
    self.pois = []
    self.max_subjects = None
    self.calibration = None

    self.init_config()

    self.threads = {}
    self.setup_interface()

  def init_config(self):
    &#34;&#34;&#34;
    Initialises all backend services in a repeatable fashion, allowing Spotted
    to be partially restarted when config changes
    &#34;&#34;&#34;

    try:
      self.config = json.load(open(&#39;config/config.json&#39;))
      load_personalities(&#39;config/personalities.json&#39;)
    except FileNotFoundError as error:
      exit_with_error(ErrorCode.MissingConfig, error)

    self.current_state = dict()
    self.stop_flags = {
      &#39;artnet&#39;: False,
      &#39;camera&#39;: False,
      &#39;fixture&#39;: False
    }

    self.setup_calibration()
    self.cameras = []
    if not self.skip_cameras:
      self.setup_cameras()
    self.setup_room()
    self.universes = Universes()
    self.pois = []
    self.setup_fixtures()
    self.setup_max_subjects()

  def setup_interface(self):
    &#34;&#34;&#34;
    Validates configured interfaces against available system interfaces and
    returns the first IPv4 address of the given interface
    &#34;&#34;&#34;

    host_interfaces = netifaces.interfaces()

    if &#39;network_interface&#39; in self.config:
      if self.config[&#39;network_interface&#39;] in host_interfaces:
        addresses = netifaces.ifaddresses(self.config[&#39;network_interface&#39;])
        if netifaces.AF_INET in addresses:
          address = addresses[netifaces.AF_INET][0]
          self.ip_address = address[&#39;addr&#39;]
          self.broadcast_address = address[&#39;broadcast&#39;]
        else:
          exit_with_error(ErrorCode.InterfaceAddress, self.config[&#39;network_interface&#39;])
      else:
        details = (self.config[&#39;network_interface&#39;], host_interfaces)
        exit_with_error(ErrorCode.MissingInterface, details)
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;network_interface&#39;)

  def setup_calibration(self):
    &#34;&#34;&#34;
    Creates the calibration object from config
    &#34;&#34;&#34;

    if &#39;calibration&#39; in self.config:
      self.calibration = Calibration(self.config[&#39;calibration&#39;])
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;calibration&#39;)

  def setup_cameras(self):
    &#34;&#34;&#34;
    Defines the cameras from config
    &#34;&#34;&#34;

    if &#39;cameras&#39; in self.config:
      if len(self.config[&#39;cameras&#39;]) &lt; 1:
        exit_with_error(ErrorCode.EmptyKey, &#39;cameras&#39;)

      for camera_id, camera in self.config[&#39;cameras&#39;].items():
        cam = Camera(camera, camera_id, self.calibration, self.stop_flags)
        self.cameras.append(cam)
        self.config[&#39;cameras&#39;][camera_id][&#39;initial_point&#39;] = cam.initial_point.as_dict()
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;cameras&#39;)

    for camera in self.cameras:
      if not camera.capture.isOpened():
        exit_with_error(ErrorCode.CameraConnect, camera.cam_id)

  def setup_room(self):
    &#34;&#34;&#34;
    Defines the room from config
    &#34;&#34;&#34;

    if &#39;room&#39; in self.config:
      room_json = self.config[&#39;room&#39;]
      self.room = Room(room_json[&#39;x&#39;], room_json[&#39;y&#39;], room_json[&#39;z&#39;])
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;room&#39;)

  def setup_max_subjects(self):
    &#34;&#34;&#34;
    Defines the maximum tracked subjects from config
    &#34;&#34;&#34;

    if &#39;max_subjects&#39; in self.config:
      self.max_subjects = self.config[&#39;max_subjects&#39;]
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;max_subjects&#39;)

  def setup_fixtures(self):
    &#34;&#34;&#34;
    Creates the fixture structure from config
    &#34;&#34;&#34;

    if &#39;fixtures&#39; in self.config:
      if len(self.config[&#39;fixtures&#39;]) &lt; 1:
        exit_with_error(ErrorCode.EmptyKey, &#39;fixtures&#39;)

      for fixture_id, fixture_config in self.config[&#39;fixtures&#39;].items():
        fixture = Fixture(fixture_config, fixture_id, self.stop_flags)
        addr = fixture.address
        universe = self.universes.get_universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
        if universe is None:
          universe = Universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
          self.universes.add_universe(universe)
        universe.add_fixture(fixture)
    else:
      exit_with_error(ErrorCode.MissingKey, &#39;fixtures&#39;)

  # pylint: disable=invalid-name, too-many-locals
  def calculate_intersection(self, poi1, poi2, close_enough, points):
    &#34;&#34;&#34;
    Determines if poi1 is close enough to poi2 to be a possibility for an intersection
    &#34;&#34;&#34;

    u = poi1.direction_vector
    v = poi2.direction_vector

    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)

    w = np.subtract(poi1.position.as_vector(), poi2.position.as_vector())
    d = np.dot(u, w)
    e = np.dot(v, w)

    acb = (a * c) - (b * b)

    s = np.dot(((b * e) - (c * d)) / acb, u)
    t = np.dot(((a * e) - (b * d)) / acb, v)

    z = abs(np.subtract(t, s))

    distance = np.add(w, z)

    euclid_distance = math.sqrt(distance[0]**2 + distance[1]**2 + distance[2]**2)

    # print(&#39;distance:&#39;, euclid_distance)

    if euclid_distance &gt; 1:
      close_enough = False
    else:
      ps = np.add(poi1.position.as_vector(), s)
      qt = np.add(poi2.position.as_vector(), t)
      abs_point = np.add(qt, ps) / 2
      if not(
          (0 &lt;= abs_point[0] &lt;= self.room.width) and
          (0 &lt;= abs_point[1] &lt;= self.room.height) and
          (0 &lt;= abs_point[2] &lt;= self.room.depth)
      ):
        close_enough = False
      else:
        points.append(abs_point)

    return (close_enough, points)

  def update_pois(self):
    &#34;&#34;&#34;
    Update 3D points of interest from all camera pois
    &#34;&#34;&#34;
    current_pois = self.combine_points()

    updated_pois = []

    # print(&#39;There are&#39;, len(current_pois), &#39;pois coming in&#39;)

    for incoming_poi in current_pois:
      new_position = incoming_poi.position
      made_update = False
      if len(self.pois) &gt; 0:
        poi = sorted(self.pois, key=lambda p, np=new_position: p.diff_from_position(np))[0]
        diff_from_pos = poi.diff_from_position(new_position)
        if diff_from_pos &lt; 1:
          # print(&#39;Updated position&#39;)
          poi.update_position(new_position)
          poi.increment_count()
          updated_pois.append(poi)
          made_update = True
          break

        if not made_update:
          poi = PointOfInterest(new_position, decrement_step=5)
          updated_pois.append(poi)
          self.pois.append(poi)
      else:
        poi = PointOfInterest(new_position, decrement_step=5)
        updated_pois.append(poi)
        self.pois.append(poi)


    missing_pois = set(self.pois) - set(updated_pois)
    for poi in missing_pois:
      poi.decrement_count()

    self.pois = [p for p in self.pois if p.count != 1]
    self.pois = sorted(self.pois, key=lambda p: p.weight, reverse=True)

  def combine_points(self):
    &#34;&#34;&#34;
    Intersects all points from all cameras to find possible 3d world points of
    interest
    &#34;&#34;&#34;

    fixture_positions = []
    for universe in self.universes.universes:
      for fixture in universe.fixtures:
        if fixture.last_position is not None:
          fixture_positions.append(fixture.last_position)

    threshold = 25

    pois = []
    for camera in self.cameras:
      fixture_camera_coordinates = []
      # inverse_rotation = np.linalg.inv(camera.rotation_matrix)
      # for fixt_pos in fixture_positions:
      #   displaced = (fixt_pos - camera.position).as_vector()

      #   # print(&#39;displaced:&#39;, displaced)

      #   # print(&#39;inverse_rotation:&#39;, inverse_rotation)

      #   identity = inverse_rotation[0].dot(displaced)
      #   identity = inverse_rotation[1].dot(identity)
      #   identity = inverse_rotation[2].dot(identity)

      #   # identity = identity

      #   print(&#39;identity:&#39;, identity)

      #   angular_displacement_horizontal = math.degrees(math.atan2(identity[2], identity[0]))
      #   angular_displacement_vertical = -math.degrees(math.atan2(identity[1], identity[0]))

      #   print(&#39;angular_displacement_horizontal:&#39;, angular_displacement_horizontal)
      #   print(&#39;angular_displacement_vertical:&#39;, angular_displacement_vertical)

      #   displacement_horizontal = round(
      #     scale(
      #       angular_displacement_horizontal,
      #       0, camera.angular_horiz_midpoint,
      #       0, camera.horiz_midpoint
      #     ) + camera.horiz_midpoint
      #   )
      #   displacement_vertical = round(
      #     scale(
      #       angular_displacement_vertical,
      #       0, camera.angular_vert_midpoint,
      #       0, camera.vert_midpoint
      #     ) + camera.vert_midpoint
      #   )

      #   print(&#39;predicted camera coordinates are&#39;, displacement_horizontal, displacement_vertical)

      #   fixture_camera_coordinates.append((displacement_horizontal, displacement_vertical))

      #   camera.current_background = np.zeros(camera.resolution_yx, dtype=np.uint8)

      #   camera_fixture_position = (displacement_vertical, displacement_horizontal)
      #   cv.circle(camera.current_background, camera_fixture_position, 15, 255, 2)

      possible_camera_pois = camera.points_of_interest
      camera_pois = []
      for poi in possible_camera_pois:
        collision = False
        for fixt_pos in fixture_camera_coordinates:
          lx, ly = poi.location
          fx, fy = fixt_pos

          if abs(lx - fx) &lt; threshold and abs(ly - fy) &lt; threshold:
            print(&#39;poi got too close&#39;)
            # collision = True

        if not collision:
          camera_pois.append(poi)





      pois.append(camera_pois)

    if len(pois) == 0:
      return []

    pois = list(itertools.product(*pois))

    # print(&#39;There are&#39;, len(pois), &#39;possible pois&#39;)

    points_of_interest = []

    for poi in pois:
      close_enough = True

      points = []

      for poi1, poi2 in itertools.combinations(poi, len(poi)):
        close, points = self.calculate_intersection(poi1, poi2, close_enough, points)
        if not close:
          close_enough = False

      if close_enough:
        poi = PointOfInterest(Coordinate(*np.mean(list(zip(*points)), axis=1)))
        points_of_interest.append(poi)

    return points_of_interest

  def start_artnet(self, transmit):
    &#34;&#34;&#34;
    Art-Net data stream generator

    Arguments:
      transmit {Queue} -- Queue to place transmittable packets onto
    &#34;&#34;&#34;

    last_poll_transmission = datetime.now()

    delay = 1
    if SystemConfig.transmit_rate == &#39;continuous&#39;:
      delay = 1/50
    elif SystemConfig.transmit_rate == &#39;reduced&#39;:
      delay = 1/15

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      # Send ArtPoll every 3 seconds
      if (datetime.now() - last_poll_transmission).total_seconds() &gt; 3:
        last_poll_transmission = datetime.now()
        packet = Poll()
        transmit.put(packet)

      for universe in self.universes.universes:
        packet = Dmx(0, universe)
        transmit.put(packet)
      time.sleep(delay)

  def start_artnet_reply(self, transmit):
    &#34;&#34;&#34;
    Listens for ArtPoll packets, and replies as necessary

    Arguments:
      transmit {Queue} -- Queue to place transmittable packets onto
    &#34;&#34;&#34;
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.setblocking(False)
    sock.bind((self.broadcast_address, 6454))

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      try:
        incoming = sock.recv(1024)

        if len(incoming) &gt; 0:
          valid, opcode, packet = identify_header(incoming)
          if valid:
            if opcode is Opcode.OpPoll:
              packet = PollReply(0, 0, self.ip_address, [0x50, 0x1A, 0xC5, 0xE7, 0xD6, 0x8F])
              transmit.put(packet)
      except BlockingIOError:
        time.sleep(1/50)

  def artnet_transmitter(self, transmit):
    &#34;&#34;&#34;
    Transmits Art-Net packets from the supplied queue constantly

    Arguments:
      transmit {Queue} -- Queue to transmit from
    &#34;&#34;&#34;

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.bind((self.ip_address, 6454))
    print(&#39;Starting artnet&#39;)

    delay = 1
    if SystemConfig.transmit_rate == &#39;continuous&#39;:
      delay = 1/50
    elif SystemConfig.transmit_rate == &#39;reduced&#39;:
      delay = 1/15

    while True:
      if self.stop_flags[&#39;artnet&#39;]:
        break

      try:
        if self.stop_flags[&#39;artnet&#39;]:
          break
        packet = transmit.get_nowait()
        sock.sendto(packet.serialize(), (self.broadcast_address, 6454))
      except queue.Empty:
        time.sleep(delay)

  def start_ui(self, server_class=HTTPServer, handler_class=StaticServer, port=8080):
    &#34;&#34;&#34;
    UI thread
    &#34;&#34;&#34;

    print(&#39;Starting UI on port&#39;, port)
    server_address = (&#39;&#39;, port)
    handler = handler_class_with_args(handler_class, self)
    httpd = server_class(server_address, handler)
    httpd.serve_forever()

  def start_websocket(self, port=8081):
    &#34;&#34;&#34;
    Websocket thread
    &#34;&#34;&#34;

    print(&#39;Starting websocket server on port&#39;, port)
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    websocket = Websocket(self)
    start_server = websockets.serve(websocket.push_state, &#39;0.0.0.0&#39;, port)
    loop.create_task(websocket.broadcast_state(1/30))
    loop.run_until_complete(start_server)
    loop.run_forever()

  def start_support_threads(self, daemon):
    &#34;&#34;&#34;
    Start all backend service threads in one go

    Arguments:
      daemon {bool} -- Start threads in daemon mode or not
    &#34;&#34;&#34;

    self.threads[&#39;cameras&#39;] = []
    for camera in self.cameras:
      thread = threading.Thread(target=camera.begin_capture, daemon=daemon)
      self.threads[&#39;cameras&#39;] = self.threads[&#39;cameras&#39;] + [thread]
      thread.start()

    transmit = queue.Queue()

    self.threads[&#39;artnet&#39;] = [
      threading.Thread(target=self.start_artnet, args=(transmit,), daemon=daemon),
      threading.Thread(target=self.start_artnet_reply, args=(transmit,), daemon=daemon),
      threading.Thread(target=self.artnet_transmitter, args=(transmit,), daemon=daemon)
    ]

    for thread in self.threads[&#39;artnet&#39;]:
      thread.start()

    self.threads[&#39;fixtures&#39;] = []
    for universe in self.universes.universes:
      for fixture in universe.fixtures:
        thread = threading.Thread(target=fixture.follow, daemon=daemon)
        self.threads[&#39;fixtures&#39;] = self.threads[&#39;fixtures&#39;] + [thread]
        thread.start()

  def start_spotted(self):
    &#34;&#34;&#34;
    Starts up all essential threads and drops to processing points from cameras
    &#34;&#34;&#34;

    daemon = False

    self.threads[&#39;ui&#39;] = [
      threading.Thread(target=self.start_ui, daemon=daemon),
      threading.Thread(target=self.start_websocket, daemon=daemon)
    ]
    for thread in self.threads[&#39;ui&#39;]:
      thread.start()

    self.start_support_threads(daemon)

    while True:
      # Uncomment this block for static values
      # point = Coordinate(2.0, 0.0, 4.0)
      # for fixture in self.universes.universes[0].fixtures:
      #   fixture.point_at(self.cameras[1].initial_point)
      #   fixture.open()
      #   # self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[index])
      # time.sleep(1/30)
      # continue

      self.update_pois()

      live_pois = self.pois

      self.current_state[&#39;cameras&#39;] = {}
      for camera in self.cameras:
        poi_positions = [poi.position.as_vector().tolist() for poi in camera.points_of_interest]
        self.current_state[&#39;cameras&#39;][camera.cam_id] = poi_positions

      self.current_state[&#39;subjects&#39;] = {}
      for poi in live_pois:
        self.current_state[&#39;subjects&#39;][id(poi)] = poi.position.as_dict()

      self.current_state[&#39;maps&#39;] = dict()

      current_poi_index = -1
      for universe in self.universes.universes:
        for fixture in universe.fixtures:
          if len(live_pois) &gt; 0:
            current_poi_index = (current_poi_index + 1) % self.max_subjects
            if current_poi_index &gt;= len(live_pois): # We&#39;ve got less than max subjects
              current_poi_index = 0
            fixture.point_at(live_pois[current_poi_index].position)
            fixture.open()

            self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[current_poi_index])

          else:
            fixture.close()

      if len(self.cameras) &gt;= 2:
        out_frame = None
        if self.cameras[0].current_frame is not None:
          out_frame = self.cameras[0].current_frame
        if self.cameras[1].current_frame is not None:
          if out_frame is not None:
            out_frame = np.vstack((out_frame, self.cameras[1].current_frame))
          else:
            out_frame = self.cameras[1].current_frame
        if out_frame is not None:
          cv.imshow(&#39;VIDEO&#39;, out_frame)
          cv.waitKey(1)
      time.sleep(1/30)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spotted.spotted.Spotted.artnet_transmitter"><code class="name flex">
<span>def <span class="ident">artnet_transmitter</span></span>(<span>self, transmit)</span>
</code></dt>
<dd>
<div class="desc"><p>Transmits Art-Net packets from the supplied queue constantly</p>
<h2 id="arguments">Arguments</h2>
<p>transmit {Queue} &ndash; Queue to transmit from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def artnet_transmitter(self, transmit):
  &#34;&#34;&#34;
  Transmits Art-Net packets from the supplied queue constantly

  Arguments:
    transmit {Queue} -- Queue to transmit from
  &#34;&#34;&#34;

  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
  sock.bind((self.ip_address, 6454))
  print(&#39;Starting artnet&#39;)

  delay = 1
  if SystemConfig.transmit_rate == &#39;continuous&#39;:
    delay = 1/50
  elif SystemConfig.transmit_rate == &#39;reduced&#39;:
    delay = 1/15

  while True:
    if self.stop_flags[&#39;artnet&#39;]:
      break

    try:
      if self.stop_flags[&#39;artnet&#39;]:
        break
      packet = transmit.get_nowait()
      sock.sendto(packet.serialize(), (self.broadcast_address, 6454))
    except queue.Empty:
      time.sleep(delay)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.calculate_intersection"><code class="name flex">
<span>def <span class="ident">calculate_intersection</span></span>(<span>self, poi1, poi2, close_enough, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if poi1 is close enough to poi2 to be a possibility for an intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_intersection(self, poi1, poi2, close_enough, points):
  &#34;&#34;&#34;
  Determines if poi1 is close enough to poi2 to be a possibility for an intersection
  &#34;&#34;&#34;

  u = poi1.direction_vector
  v = poi2.direction_vector

  a = np.dot(u, u)
  b = np.dot(u, v)
  c = np.dot(v, v)

  w = np.subtract(poi1.position.as_vector(), poi2.position.as_vector())
  d = np.dot(u, w)
  e = np.dot(v, w)

  acb = (a * c) - (b * b)

  s = np.dot(((b * e) - (c * d)) / acb, u)
  t = np.dot(((a * e) - (b * d)) / acb, v)

  z = abs(np.subtract(t, s))

  distance = np.add(w, z)

  euclid_distance = math.sqrt(distance[0]**2 + distance[1]**2 + distance[2]**2)

  # print(&#39;distance:&#39;, euclid_distance)

  if euclid_distance &gt; 1:
    close_enough = False
  else:
    ps = np.add(poi1.position.as_vector(), s)
    qt = np.add(poi2.position.as_vector(), t)
    abs_point = np.add(qt, ps) / 2
    if not(
        (0 &lt;= abs_point[0] &lt;= self.room.width) and
        (0 &lt;= abs_point[1] &lt;= self.room.height) and
        (0 &lt;= abs_point[2] &lt;= self.room.depth)
    ):
      close_enough = False
    else:
      points.append(abs_point)

  return (close_enough, points)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.combine_points"><code class="name flex">
<span>def <span class="ident">combine_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Intersects all points from all cameras to find possible 3d world points of
interest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_points(self):
  &#34;&#34;&#34;
  Intersects all points from all cameras to find possible 3d world points of
  interest
  &#34;&#34;&#34;

  fixture_positions = []
  for universe in self.universes.universes:
    for fixture in universe.fixtures:
      if fixture.last_position is not None:
        fixture_positions.append(fixture.last_position)

  threshold = 25

  pois = []
  for camera in self.cameras:
    fixture_camera_coordinates = []
    # inverse_rotation = np.linalg.inv(camera.rotation_matrix)
    # for fixt_pos in fixture_positions:
    #   displaced = (fixt_pos - camera.position).as_vector()

    #   # print(&#39;displaced:&#39;, displaced)

    #   # print(&#39;inverse_rotation:&#39;, inverse_rotation)

    #   identity = inverse_rotation[0].dot(displaced)
    #   identity = inverse_rotation[1].dot(identity)
    #   identity = inverse_rotation[2].dot(identity)

    #   # identity = identity

    #   print(&#39;identity:&#39;, identity)

    #   angular_displacement_horizontal = math.degrees(math.atan2(identity[2], identity[0]))
    #   angular_displacement_vertical = -math.degrees(math.atan2(identity[1], identity[0]))

    #   print(&#39;angular_displacement_horizontal:&#39;, angular_displacement_horizontal)
    #   print(&#39;angular_displacement_vertical:&#39;, angular_displacement_vertical)

    #   displacement_horizontal = round(
    #     scale(
    #       angular_displacement_horizontal,
    #       0, camera.angular_horiz_midpoint,
    #       0, camera.horiz_midpoint
    #     ) + camera.horiz_midpoint
    #   )
    #   displacement_vertical = round(
    #     scale(
    #       angular_displacement_vertical,
    #       0, camera.angular_vert_midpoint,
    #       0, camera.vert_midpoint
    #     ) + camera.vert_midpoint
    #   )

    #   print(&#39;predicted camera coordinates are&#39;, displacement_horizontal, displacement_vertical)

    #   fixture_camera_coordinates.append((displacement_horizontal, displacement_vertical))

    #   camera.current_background = np.zeros(camera.resolution_yx, dtype=np.uint8)

    #   camera_fixture_position = (displacement_vertical, displacement_horizontal)
    #   cv.circle(camera.current_background, camera_fixture_position, 15, 255, 2)

    possible_camera_pois = camera.points_of_interest
    camera_pois = []
    for poi in possible_camera_pois:
      collision = False
      for fixt_pos in fixture_camera_coordinates:
        lx, ly = poi.location
        fx, fy = fixt_pos

        if abs(lx - fx) &lt; threshold and abs(ly - fy) &lt; threshold:
          print(&#39;poi got too close&#39;)
          # collision = True

      if not collision:
        camera_pois.append(poi)





    pois.append(camera_pois)

  if len(pois) == 0:
    return []

  pois = list(itertools.product(*pois))

  # print(&#39;There are&#39;, len(pois), &#39;possible pois&#39;)

  points_of_interest = []

  for poi in pois:
    close_enough = True

    points = []

    for poi1, poi2 in itertools.combinations(poi, len(poi)):
      close, points = self.calculate_intersection(poi1, poi2, close_enough, points)
      if not close:
        close_enough = False

    if close_enough:
      poi = PointOfInterest(Coordinate(*np.mean(list(zip(*points)), axis=1)))
      points_of_interest.append(poi)

  return points_of_interest</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.init_config"><code class="name flex">
<span>def <span class="ident">init_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialises all backend services in a repeatable fashion, allowing Spotted
to be partially restarted when config changes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_config(self):
  &#34;&#34;&#34;
  Initialises all backend services in a repeatable fashion, allowing Spotted
  to be partially restarted when config changes
  &#34;&#34;&#34;

  try:
    self.config = json.load(open(&#39;config/config.json&#39;))
    load_personalities(&#39;config/personalities.json&#39;)
  except FileNotFoundError as error:
    exit_with_error(ErrorCode.MissingConfig, error)

  self.current_state = dict()
  self.stop_flags = {
    &#39;artnet&#39;: False,
    &#39;camera&#39;: False,
    &#39;fixture&#39;: False
  }

  self.setup_calibration()
  self.cameras = []
  if not self.skip_cameras:
    self.setup_cameras()
  self.setup_room()
  self.universes = Universes()
  self.pois = []
  self.setup_fixtures()
  self.setup_max_subjects()</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_calibration"><code class="name flex">
<span>def <span class="ident">setup_calibration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the calibration object from config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_calibration(self):
  &#34;&#34;&#34;
  Creates the calibration object from config
  &#34;&#34;&#34;

  if &#39;calibration&#39; in self.config:
    self.calibration = Calibration(self.config[&#39;calibration&#39;])
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;calibration&#39;)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_cameras"><code class="name flex">
<span>def <span class="ident">setup_cameras</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the cameras from config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_cameras(self):
  &#34;&#34;&#34;
  Defines the cameras from config
  &#34;&#34;&#34;

  if &#39;cameras&#39; in self.config:
    if len(self.config[&#39;cameras&#39;]) &lt; 1:
      exit_with_error(ErrorCode.EmptyKey, &#39;cameras&#39;)

    for camera_id, camera in self.config[&#39;cameras&#39;].items():
      cam = Camera(camera, camera_id, self.calibration, self.stop_flags)
      self.cameras.append(cam)
      self.config[&#39;cameras&#39;][camera_id][&#39;initial_point&#39;] = cam.initial_point.as_dict()
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;cameras&#39;)

  for camera in self.cameras:
    if not camera.capture.isOpened():
      exit_with_error(ErrorCode.CameraConnect, camera.cam_id)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_fixtures"><code class="name flex">
<span>def <span class="ident">setup_fixtures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the fixture structure from config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_fixtures(self):
  &#34;&#34;&#34;
  Creates the fixture structure from config
  &#34;&#34;&#34;

  if &#39;fixtures&#39; in self.config:
    if len(self.config[&#39;fixtures&#39;]) &lt; 1:
      exit_with_error(ErrorCode.EmptyKey, &#39;fixtures&#39;)

    for fixture_id, fixture_config in self.config[&#39;fixtures&#39;].items():
      fixture = Fixture(fixture_config, fixture_id, self.stop_flags)
      addr = fixture.address
      universe = self.universes.get_universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
      if universe is None:
        universe = Universe(addr[&#39;net&#39;], addr[&#39;subnet&#39;], addr[&#39;universe&#39;])
        self.universes.add_universe(universe)
      universe.add_fixture(fixture)
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;fixtures&#39;)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_interface"><code class="name flex">
<span>def <span class="ident">setup_interface</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates configured interfaces against available system interfaces and
returns the first IPv4 address of the given interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_interface(self):
  &#34;&#34;&#34;
  Validates configured interfaces against available system interfaces and
  returns the first IPv4 address of the given interface
  &#34;&#34;&#34;

  host_interfaces = netifaces.interfaces()

  if &#39;network_interface&#39; in self.config:
    if self.config[&#39;network_interface&#39;] in host_interfaces:
      addresses = netifaces.ifaddresses(self.config[&#39;network_interface&#39;])
      if netifaces.AF_INET in addresses:
        address = addresses[netifaces.AF_INET][0]
        self.ip_address = address[&#39;addr&#39;]
        self.broadcast_address = address[&#39;broadcast&#39;]
      else:
        exit_with_error(ErrorCode.InterfaceAddress, self.config[&#39;network_interface&#39;])
    else:
      details = (self.config[&#39;network_interface&#39;], host_interfaces)
      exit_with_error(ErrorCode.MissingInterface, details)
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;network_interface&#39;)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_max_subjects"><code class="name flex">
<span>def <span class="ident">setup_max_subjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the maximum tracked subjects from config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_max_subjects(self):
  &#34;&#34;&#34;
  Defines the maximum tracked subjects from config
  &#34;&#34;&#34;

  if &#39;max_subjects&#39; in self.config:
    self.max_subjects = self.config[&#39;max_subjects&#39;]
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;max_subjects&#39;)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.setup_room"><code class="name flex">
<span>def <span class="ident">setup_room</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the room from config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_room(self):
  &#34;&#34;&#34;
  Defines the room from config
  &#34;&#34;&#34;

  if &#39;room&#39; in self.config:
    room_json = self.config[&#39;room&#39;]
    self.room = Room(room_json[&#39;x&#39;], room_json[&#39;y&#39;], room_json[&#39;z&#39;])
  else:
    exit_with_error(ErrorCode.MissingKey, &#39;room&#39;)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_artnet"><code class="name flex">
<span>def <span class="ident">start_artnet</span></span>(<span>self, transmit)</span>
</code></dt>
<dd>
<div class="desc"><p>Art-Net data stream generator</p>
<h2 id="arguments">Arguments</h2>
<p>transmit {Queue} &ndash; Queue to place transmittable packets onto</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_artnet(self, transmit):
  &#34;&#34;&#34;
  Art-Net data stream generator

  Arguments:
    transmit {Queue} -- Queue to place transmittable packets onto
  &#34;&#34;&#34;

  last_poll_transmission = datetime.now()

  delay = 1
  if SystemConfig.transmit_rate == &#39;continuous&#39;:
    delay = 1/50
  elif SystemConfig.transmit_rate == &#39;reduced&#39;:
    delay = 1/15

  while True:
    if self.stop_flags[&#39;artnet&#39;]:
      break

    # Send ArtPoll every 3 seconds
    if (datetime.now() - last_poll_transmission).total_seconds() &gt; 3:
      last_poll_transmission = datetime.now()
      packet = Poll()
      transmit.put(packet)

    for universe in self.universes.universes:
      packet = Dmx(0, universe)
      transmit.put(packet)
    time.sleep(delay)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_artnet_reply"><code class="name flex">
<span>def <span class="ident">start_artnet_reply</span></span>(<span>self, transmit)</span>
</code></dt>
<dd>
<div class="desc"><p>Listens for ArtPoll packets, and replies as necessary</p>
<h2 id="arguments">Arguments</h2>
<p>transmit {Queue} &ndash; Queue to place transmittable packets onto</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_artnet_reply(self, transmit):
  &#34;&#34;&#34;
  Listens for ArtPoll packets, and replies as necessary

  Arguments:
    transmit {Queue} -- Queue to place transmittable packets onto
  &#34;&#34;&#34;
  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
  sock.setblocking(False)
  sock.bind((self.broadcast_address, 6454))

  while True:
    if self.stop_flags[&#39;artnet&#39;]:
      break

    try:
      incoming = sock.recv(1024)

      if len(incoming) &gt; 0:
        valid, opcode, packet = identify_header(incoming)
        if valid:
          if opcode is Opcode.OpPoll:
            packet = PollReply(0, 0, self.ip_address, [0x50, 0x1A, 0xC5, 0xE7, 0xD6, 0x8F])
            transmit.put(packet)
    except BlockingIOError:
      time.sleep(1/50)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_spotted"><code class="name flex">
<span>def <span class="ident">start_spotted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts up all essential threads and drops to processing points from cameras</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_spotted(self):
  &#34;&#34;&#34;
  Starts up all essential threads and drops to processing points from cameras
  &#34;&#34;&#34;

  daemon = False

  self.threads[&#39;ui&#39;] = [
    threading.Thread(target=self.start_ui, daemon=daemon),
    threading.Thread(target=self.start_websocket, daemon=daemon)
  ]
  for thread in self.threads[&#39;ui&#39;]:
    thread.start()

  self.start_support_threads(daemon)

  while True:
    # Uncomment this block for static values
    # point = Coordinate(2.0, 0.0, 4.0)
    # for fixture in self.universes.universes[0].fixtures:
    #   fixture.point_at(self.cameras[1].initial_point)
    #   fixture.open()
    #   # self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[index])
    # time.sleep(1/30)
    # continue

    self.update_pois()

    live_pois = self.pois

    self.current_state[&#39;cameras&#39;] = {}
    for camera in self.cameras:
      poi_positions = [poi.position.as_vector().tolist() for poi in camera.points_of_interest]
      self.current_state[&#39;cameras&#39;][camera.cam_id] = poi_positions

    self.current_state[&#39;subjects&#39;] = {}
    for poi in live_pois:
      self.current_state[&#39;subjects&#39;][id(poi)] = poi.position.as_dict()

    self.current_state[&#39;maps&#39;] = dict()

    current_poi_index = -1
    for universe in self.universes.universes:
      for fixture in universe.fixtures:
        if len(live_pois) &gt; 0:
          current_poi_index = (current_poi_index + 1) % self.max_subjects
          if current_poi_index &gt;= len(live_pois): # We&#39;ve got less than max subjects
            current_poi_index = 0
          fixture.point_at(live_pois[current_poi_index].position)
          fixture.open()

          self.current_state[&#39;maps&#39;][fixture.fixture_id] = id(live_pois[current_poi_index])

        else:
          fixture.close()

    if len(self.cameras) &gt;= 2:
      out_frame = None
      if self.cameras[0].current_frame is not None:
        out_frame = self.cameras[0].current_frame
      if self.cameras[1].current_frame is not None:
        if out_frame is not None:
          out_frame = np.vstack((out_frame, self.cameras[1].current_frame))
        else:
          out_frame = self.cameras[1].current_frame
      if out_frame is not None:
        cv.imshow(&#39;VIDEO&#39;, out_frame)
        cv.waitKey(1)
    time.sleep(1/30)</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_support_threads"><code class="name flex">
<span>def <span class="ident">start_support_threads</span></span>(<span>self, daemon)</span>
</code></dt>
<dd>
<div class="desc"><p>Start all backend service threads in one go</p>
<h2 id="arguments">Arguments</h2>
<p>daemon {bool} &ndash; Start threads in daemon mode or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_support_threads(self, daemon):
  &#34;&#34;&#34;
  Start all backend service threads in one go

  Arguments:
    daemon {bool} -- Start threads in daemon mode or not
  &#34;&#34;&#34;

  self.threads[&#39;cameras&#39;] = []
  for camera in self.cameras:
    thread = threading.Thread(target=camera.begin_capture, daemon=daemon)
    self.threads[&#39;cameras&#39;] = self.threads[&#39;cameras&#39;] + [thread]
    thread.start()

  transmit = queue.Queue()

  self.threads[&#39;artnet&#39;] = [
    threading.Thread(target=self.start_artnet, args=(transmit,), daemon=daemon),
    threading.Thread(target=self.start_artnet_reply, args=(transmit,), daemon=daemon),
    threading.Thread(target=self.artnet_transmitter, args=(transmit,), daemon=daemon)
  ]

  for thread in self.threads[&#39;artnet&#39;]:
    thread.start()

  self.threads[&#39;fixtures&#39;] = []
  for universe in self.universes.universes:
    for fixture in universe.fixtures:
      thread = threading.Thread(target=fixture.follow, daemon=daemon)
      self.threads[&#39;fixtures&#39;] = self.threads[&#39;fixtures&#39;] + [thread]
      thread.start()</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_ui"><code class="name flex">
<span>def <span class="ident">start_ui</span></span>(<span>self, server_class=http.server.HTTPServer, handler_class=spotted.static_server.StaticServer, port=8080)</span>
</code></dt>
<dd>
<div class="desc"><p>UI thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_ui(self, server_class=HTTPServer, handler_class=StaticServer, port=8080):
  &#34;&#34;&#34;
  UI thread
  &#34;&#34;&#34;

  print(&#39;Starting UI on port&#39;, port)
  server_address = (&#39;&#39;, port)
  handler = handler_class_with_args(handler_class, self)
  httpd = server_class(server_address, handler)
  httpd.serve_forever()</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.start_websocket"><code class="name flex">
<span>def <span class="ident">start_websocket</span></span>(<span>self, port=8081)</span>
</code></dt>
<dd>
<div class="desc"><p>Websocket thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_websocket(self, port=8081):
  &#34;&#34;&#34;
  Websocket thread
  &#34;&#34;&#34;

  print(&#39;Starting websocket server on port&#39;, port)
  loop = asyncio.new_event_loop()
  asyncio.set_event_loop(loop)
  websocket = Websocket(self)
  start_server = websockets.serve(websocket.push_state, &#39;0.0.0.0&#39;, port)
  loop.create_task(websocket.broadcast_state(1/30))
  loop.run_until_complete(start_server)
  loop.run_forever()</code></pre>
</details>
</dd>
<dt id="spotted.spotted.Spotted.update_pois"><code class="name flex">
<span>def <span class="ident">update_pois</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update 3D points of interest from all camera pois</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_pois(self):
  &#34;&#34;&#34;
  Update 3D points of interest from all camera pois
  &#34;&#34;&#34;
  current_pois = self.combine_points()

  updated_pois = []

  # print(&#39;There are&#39;, len(current_pois), &#39;pois coming in&#39;)

  for incoming_poi in current_pois:
    new_position = incoming_poi.position
    made_update = False
    if len(self.pois) &gt; 0:
      poi = sorted(self.pois, key=lambda p, np=new_position: p.diff_from_position(np))[0]
      diff_from_pos = poi.diff_from_position(new_position)
      if diff_from_pos &lt; 1:
        # print(&#39;Updated position&#39;)
        poi.update_position(new_position)
        poi.increment_count()
        updated_pois.append(poi)
        made_update = True
        break

      if not made_update:
        poi = PointOfInterest(new_position, decrement_step=5)
        updated_pois.append(poi)
        self.pois.append(poi)
    else:
      poi = PointOfInterest(new_position, decrement_step=5)
      updated_pois.append(poi)
      self.pois.append(poi)


  missing_pois = set(self.pois) - set(updated_pois)
  for poi in missing_pois:
    poi.decrement_count()

  self.pois = [p for p in self.pois if p.count != 1]
  self.pois = sorted(self.pois, key=lambda p: p.weight, reverse=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spotted" href="index.html">spotted</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spotted.spotted.Spotted" href="#spotted.spotted.Spotted">Spotted</a></code></h4>
<ul class="">
<li><code><a title="spotted.spotted.Spotted.artnet_transmitter" href="#spotted.spotted.Spotted.artnet_transmitter">artnet_transmitter</a></code></li>
<li><code><a title="spotted.spotted.Spotted.calculate_intersection" href="#spotted.spotted.Spotted.calculate_intersection">calculate_intersection</a></code></li>
<li><code><a title="spotted.spotted.Spotted.combine_points" href="#spotted.spotted.Spotted.combine_points">combine_points</a></code></li>
<li><code><a title="spotted.spotted.Spotted.init_config" href="#spotted.spotted.Spotted.init_config">init_config</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_calibration" href="#spotted.spotted.Spotted.setup_calibration">setup_calibration</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_cameras" href="#spotted.spotted.Spotted.setup_cameras">setup_cameras</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_fixtures" href="#spotted.spotted.Spotted.setup_fixtures">setup_fixtures</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_interface" href="#spotted.spotted.Spotted.setup_interface">setup_interface</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_max_subjects" href="#spotted.spotted.Spotted.setup_max_subjects">setup_max_subjects</a></code></li>
<li><code><a title="spotted.spotted.Spotted.setup_room" href="#spotted.spotted.Spotted.setup_room">setup_room</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_artnet" href="#spotted.spotted.Spotted.start_artnet">start_artnet</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_artnet_reply" href="#spotted.spotted.Spotted.start_artnet_reply">start_artnet_reply</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_spotted" href="#spotted.spotted.Spotted.start_spotted">start_spotted</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_support_threads" href="#spotted.spotted.Spotted.start_support_threads">start_support_threads</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_ui" href="#spotted.spotted.Spotted.start_ui">start_ui</a></code></li>
<li><code><a title="spotted.spotted.Spotted.start_websocket" href="#spotted.spotted.Spotted.start_websocket">start_websocket</a></code></li>
<li><code><a title="spotted.spotted.Spotted.update_pois" href="#spotted.spotted.Spotted.update_pois">update_pois</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>